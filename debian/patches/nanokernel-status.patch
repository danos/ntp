From: Kurt Roeckx <kurt@roeckx.be>
Subject: Detect that the kernel has nano support or not.
Bug: https://support.ntp.org/bugs/show_bug.cgi?id=888

The code assumed that if STA_NANO is defined the kernel has nano
support.  But on Linux, only kernel 2.6.26 and later have nano
kernel support.  If run on an older kernel, ntpd does not behave
properly because all values it sends to the kernel are
off by a factor 1000.

When the nano kernel was designed there was logic added to
detect it.  But this got removed from the ntpd binary.  This
adds the code again like it was in 4.2.0.

Index: ntp-4.2.4p6+dfsg/ntpd/ntp_loopfilter.c
===================================================================
--- ntp-4.2.4p6+dfsg.orig/ntpd/ntp_loopfilter.c	2009-11-13 17:40:36.000000000 +0100
+++ ntp-4.2.4p6+dfsg/ntpd/ntp_loopfilter.c	2009-11-13 18:00:49.000000000 +0100
@@ -137,6 +137,7 @@
 #ifdef KERNEL_PLL
 struct timex ntv;		/* kernel API parameters */
 int	pll_status;		/* status bits for kernel pll */
+int	pll_nano;		/* nanosecond kernel switch */
 #endif /* KERNEL_PLL */
 
 /*
@@ -567,24 +568,23 @@
 			struct tm *tm = NULL;
 			time_t tstamp;
 
-#ifdef STA_NANO
-			ntv.modes = MOD_BITS | MOD_NANO;
-#else /* STA_NANO */
-			ntv.modes = MOD_BITS;
-#endif /* STA_NANO */
+			if (pll_nano)
+				ntv.modes = MOD_BITS | MOD_NANO;
+			else
+				ntv.modes = MOD_BITS;
 			if (clock_offset < 0)
 				dtemp = -.5;
 			else
 				dtemp = .5;
-#ifdef STA_NANO
-			ntv.offset = (int32)(clock_offset * 1e9 +
-			    dtemp);
-			ntv.constant = sys_poll;
-#else /* STA_NANO */
-			ntv.offset = (int32)(clock_offset * 1e6 +
-			    dtemp);
-			ntv.constant = sys_poll - 4;
-#endif /* STA_NANO */
+			if (pll_nano) {
+				ntv.offset = (int32)(clock_offset * 1e9 +
+				    dtemp);
+				ntv.constant = sys_poll;
+			} else {
+				ntv.offset = (int32)(clock_offset * 1e6 +
+				    dtemp);
+				ntv.constant = sys_poll - 4;
+			}
 
 			/*
 			 * The frequency is set directly only if
@@ -654,11 +654,10 @@
 				    ntv.status);
 		}
 		pll_status = ntv.status;
-#ifdef STA_NANO
-		clock_offset = ntv.offset / 1e9;
-#else /* STA_NANO */
-		clock_offset = ntv.offset / 1e6;
-#endif /* STA_NANO */
+		if (pll_nano)
+			clock_offset = ntv.offset / 1e9;
+		else
+			clock_offset = ntv.offset / 1e6;
 		clock_frequency = ntv.freq / 65536e6;
 		flladj = plladj = 0;
 
@@ -667,11 +666,10 @@
 		 */
 		if (ntv.status & STA_PPSTIME) {
 			pps_control = current_time;
-#ifdef STA_NANO
-			clock_jitter = ntv.jitter / 1e9;
-#else /* STA_NANO */
-			clock_jitter = ntv.jitter / 1e6;
-#endif /* STA_NANO */
+			if (pll_nano)
+				clock_jitter = ntv.jitter / 1e9;
+			else
+				clock_jitter = ntv.jitter / 1e6;
 		}
 	} else {
 #endif /* KERNEL_PLL */
@@ -932,6 +930,8 @@
 		pll_status = ntv.status;
 		if (pll_control) {
 #ifdef STA_NANO
+			if (pll_status & STA_NANO)
+				pll_nano = 1;
 			if (pll_status & STA_CLK)
 				ext_enable = 1;
 #endif /* STA_NANO */
